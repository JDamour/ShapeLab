// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel densityModificator

float MIN_DENSITY;
float MAX_DENSITY;

float toolPower;
float cosStrength;
float modRange;
uint dimension;
int sign;
float4 modCenter;
float4 Bounding_offSet;

//static
float PI = 3.14159265;

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWStructuredBuffer<float> voxel;

[numthreads(8,8,8)]
void densityModificator (uint3 id : SV_DispatchThreadID)
{
    if (id.x == 0 || id.x == dimension - 1 || id.y == 0 || id.y == dimension - 1 || id.z == 0 || id.z == dimension - 1)
		return;
	// this voxel will be changed in this iteration
	uint voxelIndex = id.x + id.y * (dimension) + id.z * (dimension) * (dimension);
	float newDensity;
	float4 voxelPos = {id.x, id.y, id.z, 1.0};
	float dist = distance(voxelPos, modCenter);

	if(dist > modRange){
		return;
	}
	
	newDensity = voxel[voxelIndex] + sign * pow(abs(cosStrength*cos(dist/modRange*PI)),toolPower);

	//newDensity = voxel[voxelIndex] - 0.1;

	voxel[voxelIndex] = max(min(newDensity,MAX_DENSITY),MIN_DENSITY);
}

#pragma kernel smoothModificator

[numthreads(8,8,8)]
void smoothModificator (uint3 id : SV_DispatchThreadID)
{
    if (id.x == 0 || id.x == dimension - 1 || id.y == 0 || id.y == dimension - 1 || id.z == 0 || id.z == dimension - 1)
		return;
	
	uint voxelIndex = id.x + id.y * (dimension) + id.z * (dimension) * (dimension);

	if(voxel[voxelIndex] > 0.5f){
		return;
	}
	//get sourrounding voxels desities
	uint indecies[6] = {
		id.x+1 + (id.y) * (dimension) + id.z * (dimension) * (dimension),
		id.x-1 + (id.y) * (dimension) + id.z * (dimension) * (dimension),
		id.x + (id.y+1) * (dimension) + id.z * (dimension) * (dimension),
		id.x + (id.y-1) * (dimension) + id.z * (dimension) * (dimension),
		id.x + id.y * (dimension) + (id.z-1) * (dimension) * (dimension),
		id.x + id.y * (dimension) + (id.z+1) * (dimension) * (dimension),
	};


	float newDensity = (voxel[voxelIndex]*5.0f+
						voxel[indecies[0]] + 
						voxel[indecies[1]] + 
						voxel[indecies[2]] + 
						voxel[indecies[3]] + 
						voxel[indecies[4]] + 
						voxel[indecies[5]] 
						)/11.0f;

	voxel[voxelIndex] = max(min(newDensity,MAX_DENSITY),MIN_DENSITY);
}
